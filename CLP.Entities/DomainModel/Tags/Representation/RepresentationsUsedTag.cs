using System;
using System.Collections.Generic;
using System.Linq;
using Catel.Data;

namespace CLP.Entities
{
    public enum RepresentationsUsedTypes
    {
        BlankPage,
        InkOnly,
        RepresentationsUsed
    }

    [Serializable]
    public class UsedRepresentation : AEntityBase
    {
        #region Constructors

        public UsedRepresentation() { }

        #endregion // Constructors

        #region Properties

        /// <summary>Coded value of the Representation.</summary>
        public string CodedObject
        {
            get { return GetValue<string>(CodedObjectProperty); }
            set { SetValue(CodedObjectProperty, value); }
        }

        public static readonly PropertyData CodedObjectProperty = RegisterProperty("CodedObject", typeof(string), string.Empty);

        /// <summary>Coded ID of the Representation.</summary>
        public string CodedID
        {
            get { return GetValue<string>(CodedIDProperty); }
            set { SetValue(CodedIDProperty, value); }
        }

        public static readonly PropertyData CodedIDProperty = RegisterProperty("CodedID", typeof(string), string.Empty);

        /// <summary>Information considered part of the make-up of the Representation.</summary>
        public string RepresentationInformation
        {
            get { return GetValue<string>(RepresentationInformationProperty); }
            set { SetValue(RepresentationInformationProperty, value); }
        }

        public static readonly PropertyData RepresentationInformationProperty = RegisterProperty("RepresentationInformation", typeof(string), string.Empty);

        /// <summary>Representational Correctness of this particular Representation.</summary>
        public Correctness Correctness
        {
            get { return GetValue<Correctness>(CorrectnessProperty); }
            set { SetValue(CorrectnessProperty, value); }
        }

        public static readonly PropertyData CorrectnessProperty = RegisterProperty("Correctness", typeof(Correctness), Correctness.Unknown);

        /// <summary>If applicable, lists a reason for Correctness set to Partial or Incorrect.</summary>
        public string CorrectnessReason
        {
            get { return GetValue<string>(CorrectnessReasonProperty); }
            set { SetValue(CorrectnessReasonProperty, value); }
        }

        public static readonly PropertyData CorrectnessReasonProperty = RegisterProperty("CorrectnessReason", typeof(string), Codings.PARTIAL_REASON_UNKNOWN);

        /// <summary>The part/side of the page definition the Representation matchec correctness against.</summary>
        public string MatchedRelationSide
        {
            get { return GetValue<string>(MatchedRelationSideProperty); }
            set { SetValue(MatchedRelationSideProperty, value); }
        }

        public static readonly PropertyData MatchedRelationSideProperty = RegisterProperty("MatchedRelationSide", typeof(string), string.Empty);
        
        /// <summary>Signifies the Representation is still on the page at the time of submission.</summary>
        public bool IsFinalRepresentation
        {
            get { return GetValue<bool>(IsFinalRepresentationProperty); }
            set { SetValue(IsFinalRepresentationProperty, value); }
        }

        public static readonly PropertyData IsFinalRepresentationProperty = RegisterProperty("IsFinalRepresentation", typeof(bool), false);

        /// <summary>Signifies the Representation was used, as determined by the specific Representation type.</summary>
        public bool IsUsed
        {
            get { return GetValue<bool>(IsUsedProperty); }
            set { SetValue(IsUsedProperty, value); }
        }

        public static readonly PropertyData IsUsedProperty = RegisterProperty("IsUsed", typeof(bool), false);

        /// <summary>Signifies the Representation was interacted with, as determined by the specific Representation type.</summary>
        public bool IsInteractedWith
        {
            get { return GetValue<bool>(IsInteractedWithProperty); }
            set { SetValue(IsInteractedWithProperty, value); }
        }

        public static readonly PropertyData IsInteractedWithProperty = RegisterProperty("IsInteractedWith", typeof(bool), false);

        /// <summary>Any extra information relevant to the compiled Representation information.</summary>
        public List<string> AdditionalInformation
        {
            get { return GetValue<List<string>>(AdditionalInformationProperty); }
            set { SetValue(AdditionalInformationProperty, value); }
        }

        public static readonly PropertyData AdditionalInformationProperty = RegisterProperty("AdditionalInformation", typeof(List<string>), () => new List<string>());

        /// <summary>List of any Analysis Codes generated by the Representation.</summary>
        public List<string> AnalysisCodes
        {
            get { return GetValue<List<string>>(AnalysisCodesProperty); }
            set { SetValue(AnalysisCodesProperty, value); }
        }

        public static readonly PropertyData AnalysisCodesProperty = RegisterProperty("AnalysisCodes", typeof(List<string>), () => new List<string>());

        public string FormattedValue
        {
            get
            {
                // OJBJECT [ID] RepresentationInfo
                //      - Unused/No Interaction
                //      - Correct, LS
                //      - additional info
                //      - additional info
                //      - Analysis Codes:

                var header = $"{CodedObject} [{CodedID}] {RepresentationInformation}";
                var sections = new List<string>();

                var usage = IsUsed ? string.Empty : "Unused";
                if (string.IsNullOrWhiteSpace(usage))
                {
                    usage = IsInteractedWith ? string.Empty : "No Interaction";
                }
                if (!string.IsNullOrWhiteSpace(usage))
                {
                    sections.Add(usage);
                }

                if (Correctness != Correctness.Unknown)
                {
                    var correctnessSection = $"{Correctness}, {MatchedRelationSide}";
                    sections.Add(correctnessSection);
                }

                sections.AddRange(AdditionalInformation);

                var formattedAnalysisCodes = string.Join(", ", AnalysisCodes);
                var formattedAnalysisCodeSection = $"Analysis Codes: {formattedAnalysisCodes}";
                sections.Add(formattedAnalysisCodeSection);

                var formattedSections = string.Join("\n  - ", sections);
                var formattedValue = $"{header}\n{formattedSections}";

                return formattedValue;
            }
        }

        #endregion // Properties
    }

    [Serializable]
    public class RepresentationsUsedTag : AAnalysisTagBase
    {
        #region Constructors

        public RepresentationsUsedTag() { }

        public RepresentationsUsedTag(CLPPage parentPage, Origin origin)
            : base(parentPage, origin) { }

        #endregion //Constructors

        #region Properties

        /// <summary>Identifies 3 possible usages scenarios: Ink Only, Blank Page, or Representations Used.</summary>
        public RepresentationsUsedTypes RepresentationsUsedType
        {
            get { return GetValue<RepresentationsUsedTypes>(RepresentationsUsedTypeProperty); }
            set { SetValue(RepresentationsUsedTypeProperty, value); }
        }

        public static readonly PropertyData RepresentationsUsedTypeProperty = RegisterProperty("RepresentationsUsedType", typeof(RepresentationsUsedTypes), RepresentationsUsedTypes.BlankPage);

        /// <summary>List of all Representations used on the page.</summary>
        /// <remarks>The IsUsed property can still be set to false, this is a list of all Representations added to the page, 
        /// the IsUsed property determines if the Representation was also used on the page in a significant fashion.</remarks>
        public List<UsedRepresentation> RepresentationsUsed
        {
            get { return GetValue<List<UsedRepresentation>>(RepresentationsUsedProperty); }
            set { SetValue(RepresentationsUsedProperty, value); }
        }

        public static readonly PropertyData RepresentationsUsedProperty = RegisterProperty("RepresentationsUsed", typeof(List<UsedRepresentation>), () => new List<UsedRepresentation>());
        
        #region ATagBase Overrides

        public override bool IsSingleValueTag => true;

        public override Category Category => Category.Representation;

        public override string FormattedName => "Representations Used";

        public override string FormattedValue
        {
            get
            {
                switch (RepresentationsUsedType)
                {
                    case RepresentationsUsedTypes.BlankPage:
                        return "Blank Page";
                    case RepresentationsUsedTypes.InkOnly:
                        return "Ink Only";
                }

                var deletedRepresentations = RepresentationsUsed.Where(r => !r.IsFinalRepresentation).ToList();
                var deletedSection = !deletedRepresentations.Any() ? string.Empty : $"Deleted Representation(s):\n{string.Join("\n", deletedRepresentations.Select(r => r.FormattedValue).ToList())}";

                var finalRepresentations = RepresentationsUsed.Where(r => r.IsFinalRepresentation).ToList();
                var finalSection = !finalRepresentations.Any() ? string.Empty : $"Final Representation(s):\n{string.Join("\n", finalRepresentations.Select(r => r.FormattedValue).ToList())}";

                var finalSectionDelimiter = deletedRepresentations.Any() && finalRepresentations.Any() ? "\n" : string.Empty;

                var codeSection = AnalysisCodes.Any() ? $"\n\nCodes: {string.Join(", ", AnalysisCodes)}" : string.Empty;
                return $"{deletedSection}{finalSectionDelimiter}{finalSection}{codeSection}";
            }
        }

        #endregion //ATagBase Overrides

        #endregion //Properties

        #region Static Methods

        #region Nested Class

        private class PatternPoint
        {
            public PatternPoint()
            {
                StartHistoryActionIndex = -1;
                StartSemanticEventIndex = -1;
                EndHistoryActionIndex = -1;
                EndSemanticEventIndex = -1;
            }

            public string PageObjectID { get; set; }

            public int StartHistoryActionIndex { get; set; }
            public int StartSemanticEventIndex { get; set; }
            public int EndHistoryActionIndex { get; set; }
            public int EndSemanticEventIndex { get; set; }
            public string StartEventType { get; set; }
            public string EndEventType { get; set; }
        }

        #endregion // Nested Class

        public static RepresentationsUsedTag AttemptTagGeneration(CLPPage page, List<ISemanticEvent> semanticEvents)
        {
            var tag = new RepresentationsUsedTag(page, Origin.StudentPageGenerated);

            var leftRelation = RepresentationCorrectnessTag.GenerateLeftRelationFromPageAnswerDefinition(page);
            var rightRelation = RepresentationCorrectnessTag.GenerateRightRelationFromPageAnswerDefinition(page);
            var alternativeRelation = RepresentationCorrectnessTag.GenerateAlternativeRelationFromPageAnswerDefinition(page);

            GenerateArraysUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);
            GenerateNumberLinesUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);
            GenerateStampsUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);

            if (!tag.RepresentationsUsed.Any())
            {
                if (!page.InkStrokes.Any() &&
                    !page.History.TrashedInkStrokes.Any())
                {
                    tag.RepresentationsUsedType = RepresentationsUsedTypes.BlankPage;
                }
                else
                {
                    tag.RepresentationsUsedType = RepresentationsUsedTypes.InkOnly;
                }
            }
            else
            {
                tag.RepresentationsUsedType = RepresentationsUsedTypes.RepresentationsUsed;
            }

            var isMR2STEP = IsMR2STEP(tag);
            if (isMR2STEP)
            {
                tag.AnalysisCodes.Add(Codings.REPRESENTATIONS_MR2STEP);
            }

            page.AddTag(tag);
            return tag;
        }

        public static void GenerateArraysUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var patternPoints = new List<PatternPoint>();
            var completedPatternPoints = new List<PatternPoint>();
            var subArrayGroups = new Dictionary<string, List<string>>();

            #region Find Pattern Points

            foreach (var semanticEvent in semanticEvents.Where(e => e.CodedObject == Codings.OBJECT_ARRAY))
            {
                var arrayID = semanticEvent.ReferencePageObjectID;

                if (semanticEvent.EventType == Codings.EVENT_OBJECT_ADD)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = new PatternPoint
                                       {
                                           PageObjectID = arrayID,
                                           StartHistoryActionIndex = objectsChanged.HistoryActionIndex,
                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                           StartEventType = semanticEvent.EventType
                                       };
                    patternPoints.Add(patternPoint);
                }
                else if (semanticEvent.EventType == Codings.EVENT_CUT)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var pageObjectsCut = historyAction as PageObjectCutHistoryAction;
                    if (pageObjectsCut == null)
                    {
                        continue;
                    }

                    var patternPoint = patternPoints.FirstOrDefault(p => p.PageObjectID == arrayID);
                    if (patternPoint != null)
                    {
                        patternPoint.EndHistoryActionIndex = pageObjectsCut.HistoryActionIndex;
                        patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPoint.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPoint);
                        completedPatternPoints.Add(patternPoint);
                    }

                    foreach (var halvedArrayID in pageObjectsCut.HalvedPageObjectIDs)
                    {
                        var patternPointForArrayHalf = new PatternPoint
                                                       {
                                                           PageObjectID = halvedArrayID,
                                                           StartHistoryActionIndex = pageObjectsCut.HistoryActionIndex,
                                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                                           StartEventType = semanticEvent.EventType
                                                       };
                        patternPoints.Add(patternPointForArrayHalf);
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_SNAP)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var arraySnap = historyAction as CLPArraySnapHistoryAction;
                    if (arraySnap == null)
                    {
                        continue;
                    }

                    var persistingArrayID = arraySnap.PersistingArrayID;
                    var patternPointForPersistingArray = patternPoints.FirstOrDefault(p => p.PageObjectID == persistingArrayID);
                    if (patternPointForPersistingArray != null)
                    {
                        patternPointForPersistingArray.EndHistoryActionIndex = arraySnap.HistoryActionIndex;
                        patternPointForPersistingArray.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPointForPersistingArray.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPointForPersistingArray);
                        completedPatternPoints.Add(patternPointForPersistingArray);
                    }

                    var snappedArrayID = arraySnap.SnappedArrayID;
                    var patternPointForSnappedArray = patternPoints.FirstOrDefault(p => p.PageObjectID == snappedArrayID);
                    if (patternPointForSnappedArray != null)
                    {
                        patternPointForSnappedArray.EndHistoryActionIndex = arraySnap.HistoryActionIndex;
                        patternPointForSnappedArray.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPointForSnappedArray.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPointForSnappedArray);
                        completedPatternPoints.Add(patternPointForSnappedArray);
                    }

                    var patternPointForNewArray = new PatternPoint
                                                  {
                                                      PageObjectID = persistingArrayID,
                                                      StartHistoryActionIndex = arraySnap.HistoryActionIndex,
                                                      StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                                      StartEventType = semanticEvent.EventType
                                                  };
                    patternPoints.Add(patternPointForNewArray);
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_DIVIDE_INK)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var eventInfo = semanticEvent.EventInformation;
                    var subArrays = eventInfo.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();
                    if (!subArrayGroups.ContainsKey(arrayID))
                    {
                        subArrayGroups.Add(arrayID, subArrays);
                    }
                    else
                    {
                        subArrayGroups[arrayID].AddRange(subArrays);
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_DIVIDE_INK_ERASE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var eventInfo = semanticEvent.EventInformation;
                    var subArrays = eventInfo.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();
                    foreach (var subArray in subArrays)
                    {
                        if (!subArrayGroups.ContainsKey(arrayID))
                        {
                            continue;
                        }

                        if (!subArrayGroups[arrayID].Contains(subArray))
                        {
                            continue;
                        }

                        subArrayGroups[arrayID].Remove(subArray);
                        if (!subArrayGroups[arrayID].Any())
                        {
                            subArrayGroups.Remove(arrayID);
                        }
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_OBJECT_DELETE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = patternPoints.FirstOrDefault(p => p.PageObjectID == arrayID);
                    if (patternPoint == null)
                    {
                        continue;
                    }

                    patternPoint.EndHistoryActionIndex = objectsChanged.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                    patternPoint.EndEventType = semanticEvent.EventType;
                    patternPoints.Remove(patternPoint);
                    completedPatternPoints.Add(patternPoint);
                }
            }

            #endregion // Find Pattern Points

            foreach (var patternPoint in patternPoints)
            {
                patternPoint.EndHistoryActionIndex = semanticEvents.Last().LastHistoryAction.HistoryActionIndex;
                patternPoint.EndSemanticEventIndex = semanticEvents.Last().SemanticEventIndex;
                completedPatternPoints.Add(patternPoint);
            }

            foreach (var patternPoint in completedPatternPoints)
            {
                var arrayID = patternPoint.PageObjectID;
                var array = page.GetPageObjectByIDOnPageOrInHistory(arrayID) as CLPArray;
                if (array == null)
                {
                    continue;
                }

                var usedRepresentation = new UsedRepresentation();

                #region Basic Representation Info

                if (string.IsNullOrWhiteSpace(patternPoint.EndEventType))
                {
                    usedRepresentation.IsFinalRepresentation = true;
                }

                usedRepresentation.CodedObject = Codings.OBJECT_ARRAY;
                usedRepresentation.CodedID = array.GetCodedIDAtHistoryIndex(patternPoint.EndHistoryActionIndex);
                usedRepresentation.IsInteractedWith =
                    semanticEvents.Where(e => e.ReferencePageObjectID == arrayID)
                                  .Any(
                                       e =>
                                           e.EventType == Codings.EVENT_ARRAY_SKIP || e.EventType == Codings.EVENT_ARRAY_DIVIDE_INK || e.EventType == Codings.EVENT_ARRAY_EQN ||
                                           (e.EventType == Codings.EVENT_INK_ADD && e.EventInformation.Contains(Codings.EVENT_INFO_INK_LOCATION_OVER)));
                usedRepresentation.IsUsed = true;

                if (subArrayGroups.ContainsKey(arrayID))
                {
                    usedRepresentation.RepresentationInformation = string.Join(", ", subArrayGroups[arrayID]);
                }

                if (patternPoint.EndEventType == Codings.EVENT_CUT)
                {
                    usedRepresentation.AdditionalInformation.Add("Deleted by Cut");
                }

                if (patternPoint.EndEventType == Codings.EVENT_ARRAY_SNAP)
                {
                    usedRepresentation.AdditionalInformation.Add("Deleted by Snap");
                }

                if (patternPoint.StartEventType == Codings.EVENT_CUT)
                {
                    usedRepresentation.AdditionalInformation.Add("Created by Cut");
                }

                if (patternPoint.StartEventType == Codings.EVENT_ARRAY_SNAP)
                {
                    usedRepresentation.AdditionalInformation.Add("Created by Snap");
                }

                var mostRecentSkipEvent =
                    semanticEvents.LastOrDefault(
                                                 e =>
                                                     e.SemanticEventIndex <= patternPoint.EndSemanticEventIndex &&
                                                     (e.EventType == Codings.EVENT_ARRAY_SKIP || e.EventType == Codings.EVENT_ARRAY_SKIP_ERASE));

                if (mostRecentSkipEvent != null)
                {
                    var eventInfoParts = mostRecentSkipEvent.EventInformation.Split(", ");
                    if (eventInfoParts.Length == 2)
                    {
                        var formattedInterpretationParts = eventInfoParts[0].Split("; ");
                        if (formattedInterpretationParts.Length == 2)
                        {
                            var formattedSkips = formattedInterpretationParts[1];
                            if (!string.IsNullOrEmpty(formattedSkips))
                            {
                                // HACK: temporary print out of Wrong Dimension analysis
                                var skipStrings = formattedSkips.Split(' ').ToList().Select(s => s.Replace("\"", string.Empty)).ToList();
                                var skips = new List<int>();
                                foreach (var skip in skipStrings)
                                {
                                    if (string.IsNullOrEmpty(skip))
                                    {
                                        skips.Add(-1);
                                        continue;
                                    }

                                    int number;
                                    var isNumber = int.TryParse(skip, out number);
                                    if (isNumber)
                                    {
                                        skips.Add(number);
                                        continue;
                                    }

                                    skips.Add(-1);
                                }

                                var wrongDimensionMatches = 0;
                                for (int i = 0; i < skips.Count - 1; i++)
                                {
                                    var currentValue = skips[i];
                                    var nextValue = skips[i + 1];
                                    if (currentValue == -1 ||
                                        nextValue == -1)
                                    {
                                        continue;
                                    }
                                    var difference = nextValue - currentValue;
                                    if (difference == array.Rows &&
                                        array.Rows != array.Columns)
                                    {
                                        wrongDimensionMatches++;
                                    }
                                }

                                var wrongDimensionText = string.Empty;
                                var percentMatchWrongDimensions = wrongDimensionMatches / (skips.Count - 1) * 1.0;
                                if (percentMatchWrongDimensions >= 0.80)
                                {
                                    wrongDimensionText = ", wrong dimension";
                                }

                                var skipCodedValue = $"skip [{formattedSkips}]{wrongDimensionText}";
                                usedRepresentation.AdditionalInformation.Add(skipCodedValue);
                            }
                        }
                    }
                }

                #endregion // Basic Representation Info

                #region Representation Correctness

                // TODO: One-to-one comparison of each array at pattern points. Could take pattern point created by cut and consider those cut arrays as one?

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                var representationRelation = RepresentationCorrectnessTag.GenerateArrayRelation(array, patternPoint.EndHistoryActionIndex);

                var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                if (leftCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                    representationCorrectness = Correctness.Correct;
                }
                else if (rightCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                    representationCorrectness = Correctness.Correct;
                }
                else if (alternativeCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                    representationCorrectness = Correctness.Correct;
                }
                else if (leftCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (rightCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (leftCorrectness == Correctness.Incorrect ||
                         rightCorrectness == Correctness.Incorrect ||
                         alternativeCorrectness == Correctness.Incorrect)
                {
                    representationCorrectness = Correctness.Incorrect;
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;
                if (representationRelation.IsSwapped)
                {
                    usedRepresentation.CorrectnessReason = Codings.PARTIAL_REASON_SWAPPED;
                }

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }

            #region Static Skips

            //var formattedSkips = ArraySemanticEvents.StaticSkipCountAnalysis(page, array);


            #endregion // Static Skips
        }

        public static void GenerateNumberLinesUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var patternPoints = new List<PatternPoint>();
            var jumpGroups = new Dictionary<string, List<NumberLineJumpSize>>();
            var jumpEraseCount = new Dictionary<string, int>();

            #region Find Pattern Points

            foreach (var semanticEvent in semanticEvents.Where(e => e.CodedObject == Codings.OBJECT_NUMBER_LINE))
            {
                var numberLineID = semanticEvent.ReferencePageObjectID;

                if (semanticEvent.EventType == Codings.EVENT_OBJECT_ADD)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = new PatternPoint
                                       {
                                           PageObjectID = numberLineID,
                                           StartHistoryActionIndex = objectsChanged.HistoryActionIndex,
                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                           StartEventType = semanticEvent.EventType
                                       };
                    patternPoints.Add(patternPoint);
                }
                else if (semanticEvent.EventType == Codings.EVENT_NUMBER_LINE_JUMP)
                {
                    var jumpSizesChangedHistoryActions = semanticEvent.HistoryActions.OfType<NumberLineJumpSizesChangedHistoryAction>().ToList();
                    if (!jumpSizesChangedHistoryActions.Any())
                    {
                        continue;
                    }

                    var allJumps = new List<NumberLineJumpSize>();
                    foreach (var historyAction in jumpSizesChangedHistoryActions)
                    {
                        allJumps.AddRange(historyAction.JumpsAdded);
                    }

                    if (!jumpGroups.ContainsKey(numberLineID))
                    {
                        jumpGroups.Add(numberLineID, allJumps);
                    }
                    else
                    {
                        jumpGroups[numberLineID].AddRange(allJumps);
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_NUMBER_LINE_JUMP_ERASE)
                {
                    var jumpSizesChangedHistoryActions = semanticEvent.HistoryActions.OfType<NumberLineJumpSizesChangedHistoryAction>().ToList();
                    if (!jumpSizesChangedHistoryActions.Any())
                    {
                        continue;
                    }

                    var allJumps = new List<NumberLineJumpSize>();
                    foreach (var historyAction in jumpSizesChangedHistoryActions)
                    {
                        allJumps.AddRange(historyAction.JumpsRemoved);
                    }

                    var jumpsToRemove = (from jump in allJumps
                                         from currentJump in jumpGroups[numberLineID]
                                         where jump.JumpSize == currentJump.JumpSize && jump.StartingTickIndex == currentJump.StartingTickIndex
                                         select currentJump).ToList();

                    if (!jumpEraseCount.ContainsKey(numberLineID))
                    {
                        jumpEraseCount.Add(numberLineID, 1);
                    }
                    jumpEraseCount[numberLineID] += jumpsToRemove.Count;

                    foreach (var jump in jumpsToRemove)
                    {
                        if (!jumpGroups.ContainsKey(numberLineID))
                        {
                            continue;
                        }

                        jumpGroups[numberLineID].Remove(jump);
                        if (!jumpGroups[numberLineID].Any())
                        {
                            jumpGroups.Remove(numberLineID);
                        }
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_OBJECT_DELETE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = patternPoints.FirstOrDefault(p => p.PageObjectID == numberLineID);
                    if (patternPoint == null)
                    {
                        continue;
                    }

                    patternPoint.EndHistoryActionIndex = objectsChanged.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                    patternPoint.EndEventType = semanticEvent.EventType;
                }
            }

            #endregion // Find Pattern Points

            foreach (var patternPoint in patternPoints)
            {
                var numberLineID = patternPoint.PageObjectID;
                var numberLine = page.GetPageObjectByIDOnPageOrInHistory(numberLineID) as NumberLine;
                if (numberLine == null)
                {
                    continue;
                }

                var usedRepresentation = new UsedRepresentation();

                #region Basic Representation Info

                usedRepresentation.IsFinalRepresentation = false;
                if (patternPoint.EndHistoryActionIndex == -1)
                {
                    patternPoint.EndHistoryActionIndex = semanticEvents.Last().LastHistoryAction.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvents.Last().SemanticEventIndex;
                    usedRepresentation.IsFinalRepresentation = true;
                }

                usedRepresentation.CodedObject = Codings.OBJECT_NUMBER_LINE;
                usedRepresentation.CodedID = numberLine.GetCodedIDAtHistoryIndex(patternPoint.EndHistoryActionIndex);
                usedRepresentation.IsInteractedWith =
                    semanticEvents.Where(e => e.ReferencePageObjectID == numberLineID).Any(e => e.EventType == Codings.EVENT_NUMBER_LINE_JUMP || e.EventType == Codings.EVENT_NUMBER_LINE_CHANGE);
                usedRepresentation.IsUsed = jumpGroups.ContainsKey(numberLineID);
                if (usedRepresentation.IsUsed)
                {
                    usedRepresentation.RepresentationInformation = NumberLine.ConsolidateJumps(jumpGroups[numberLineID].ToList());
                }

                if (!string.IsNullOrEmpty(usedRepresentation.RepresentationInformation))
                {
                    var jumpsInEnglish = new List<string>();
                    foreach (var codedJump in usedRepresentation.RepresentationInformation.Split("; ", StringSplitOptions.RemoveEmptyEntries))
                    {
                        try
                        {
                            var jumpSegments = codedJump.Split(", ", StringSplitOptions.RemoveEmptyEntries);
                            var jumpSize = int.Parse(jumpSegments[0]);
                            var jumpRange = jumpSegments[1].Split('-');
                            var start = int.Parse(jumpRange[0]);
                            var stop = int.Parse(jumpRange[1]);
                            var numberOfJumps = (stop - start) / jumpSize;
                            var jumpString = numberOfJumps == 1 ? "jump" : "jumps";
                            var jumpInEnglish = $"{numberOfJumps} {jumpString} of {jumpSize}";
                            jumpsInEnglish.Add(jumpInEnglish);
                        }
                        catch (Exception)
                        {
                            // ignored
                        }
                    }

                    usedRepresentation.AdditionalInformation.AddRange(jumpsInEnglish);
                }

                if (jumpEraseCount.ContainsKey(numberLineID) &&
                    jumpEraseCount[numberLineID] > 1)
                {
                    usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_NLJE);
                }

                #endregion // Basic Representation Info

                #region Representation Correctness

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                if (usedRepresentation.IsUsed)
                {
                    var jumpSizes = jumpGroups[numberLineID];
                    var representationRelation = RepresentationCorrectnessTag.GenerateNumberLineRelation(jumpSizes);

                    var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                    var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                    var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                    if (leftCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (rightCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (alternativeCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (leftCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (rightCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (leftCorrectness == Correctness.Incorrect ||
                             rightCorrectness == Correctness.Incorrect ||
                             alternativeCorrectness == Correctness.Incorrect)
                    {
                        representationCorrectness = Correctness.Incorrect;
                    }
                }
                else
                {
                    var codedID = usedRepresentation.CodedID;

                    if (leftRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = leftRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }

                    if (rightRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = rightRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }

                    if (alternativeRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = alternativeRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }
        }

        public static void GenerateStampsUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var stampedObjectGroups = new Dictionary<int,int>();  // <Parts,Number of StampedObjects with Parts Value>
            var parentStampIDsOfParts = new Dictionary<int,List<string>>();
            foreach (var stampedObject in page.PageObjects.OfType<StampedObject>())
            {
                var parts = stampedObject.Parts;
                if (stampedObjectGroups.ContainsKey(parts))
                {
                    stampedObjectGroups[parts]++;
                }
                else
                {
                    stampedObjectGroups.Add(parts, 1);
                }

                if (parentStampIDsOfParts.ContainsKey(parts))
                {
                    parentStampIDsOfParts[parts].Add(stampedObject.ParentStampID);
                }
                else
                {
                    var parentStampIDs = new List<string>
                                         {
                                             stampedObject.ParentStampID
                                         };
                    parentStampIDsOfParts.Add(parts, parentStampIDs);
                }
            }

            foreach (var key in stampedObjectGroups.Keys)
            {
                var parts = key;
                var numberOfStampedObjects = stampedObjectGroups[key];

                var usedRepresentation = new UsedRepresentation();

                #region Basic Representation Info

                usedRepresentation.IsFinalRepresentation = true;

                usedRepresentation.CodedObject = Codings.OBJECT_STAMP;
                usedRepresentation.CodedID = parts.ToString();
                usedRepresentation.IsInteractedWith = true;
                usedRepresentation.IsUsed = true;
                usedRepresentation.RepresentationInformation = $"{numberOfStampedObjects} image(s)";

                var groupString = stampedObjectGroups[key] == 1 ? "group" : "groups";
                var englishValue = $"{stampedObjectGroups[key]} {groupString} of {parts}";
                usedRepresentation.AdditionalInformation.Add(englishValue);

                var parentStampsCount = parentStampIDsOfParts[key].Distinct().Count();
                var parentStampInfo = $"From {parentStampsCount} Stamps";
                usedRepresentation.AdditionalInformation.Add(parentStampInfo);

                #endregion // Basic Representation Info

                #region Representation Correctness

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                if (usedRepresentation.IsUsed)
                {
                    var representationRelation = RepresentationCorrectnessTag.GenerateStampedObjectsRelation(parts, numberOfStampedObjects);

                    var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                    var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                    var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                    if (leftCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (rightCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (alternativeCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (leftCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (rightCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (leftCorrectness == Correctness.Incorrect ||
                             rightCorrectness == Correctness.Incorrect ||
                             alternativeCorrectness == Correctness.Incorrect)
                    {
                        representationCorrectness = Correctness.Incorrect;
                    }
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }
        }

        public static bool IsMR2STEP(RepresentationsUsedTag tag)
        {
            var leftSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_LEFT && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();
            var rightSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_RIGHT && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();
            var alternativeSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_ALTERNATIVE && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();

            var unmatchedRepresentations =
                tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_NONE && r.Correctness == Correctness.Incorrect).Select(r => r.CodedObject).Distinct().ToList();

            // TODO: Doesn't handle altReps

            if (!leftSideRepresentations.Any() ||
                !rightSideRepresentations.Any())
            {
                return false;
            }

            foreach (var leftSideRepresentation in leftSideRepresentations)
            {
                if (!rightSideRepresentations.Contains(leftSideRepresentation))
                {
                    return true;
                }

                if (!unmatchedRepresentations.Contains(leftSideRepresentation))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion // Static Methods
    }
}