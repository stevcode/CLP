using System;
using System.Collections.Generic;
using System.Linq;
using Catel.Data;

namespace CLP.Entities
{
    public enum RepresentationsUsedTypes
    {
        BlankPage,
        InkOnly,
        RepresentationsUsed
    }

    [Serializable]
    public class UsedRepresentation : AEntityBase
    {
        #region Constructors

        public UsedRepresentation() { }

        #endregion // Constructors

        #region Properties

        /// <summary>Coded value of the Representation.</summary>
        public string CodedObject
        {
            get { return GetValue<string>(CodedObjectProperty); }
            set { SetValue(CodedObjectProperty, value); }
        }

        public static readonly PropertyData CodedObjectProperty = RegisterProperty("CodedObject", typeof(string), string.Empty);

        /// <summary>Coded ID of the Representation.</summary>
        public string CodedID
        {
            get { return GetValue<string>(CodedIDProperty); }
            set { SetValue(CodedIDProperty, value); }
        }

        public static readonly PropertyData CodedIDProperty = RegisterProperty("CodedID", typeof(string), string.Empty);

        /// <summary>Information considered part of the make-up of the Representation.</summary>
        public string RepresentationInformation
        {
            get { return GetValue<string>(RepresentationInformationProperty); }
            set { SetValue(RepresentationInformationProperty, value); }
        }

        public static readonly PropertyData RepresentationInformationProperty = RegisterProperty("RepresentationInformation", typeof(string), string.Empty);

        /// <summary>Representational Correctness of this particular Representation.</summary>
        public Correctness Correctness
        {
            get { return GetValue<Correctness>(CorrectnessProperty); }
            set { SetValue(CorrectnessProperty, value); }
        }

        public static readonly PropertyData CorrectnessProperty = RegisterProperty("Correctness", typeof(Correctness), Correctness.Unknown);

        /// <summary>If applicable, lists a reason for Correctness set to Partial or Incorrect.</summary>
        public string CorrectnessReason
        {
            get { return GetValue<string>(CorrectnessReasonProperty); }
            set { SetValue(CorrectnessReasonProperty, value); }
        }

        public static readonly PropertyData CorrectnessReasonProperty = RegisterProperty("CorrectnessReason", typeof(string), Codings.PARTIAL_REASON_UNKNOWN);

        /// <summary>The part/side of the page definition the Representation matchec correctness against.</summary>
        public string MatchedRelationSide
        {
            get { return GetValue<string>(MatchedRelationSideProperty); }
            set { SetValue(MatchedRelationSideProperty, value); }
        }

        public static readonly PropertyData MatchedRelationSideProperty = RegisterProperty("MatchedRelationSide", typeof(string), string.Empty);
        
        /// <summary>Signifies the Representation is still on the page at the time of submission.</summary>
        public bool IsFinalRepresentation
        {
            get { return GetValue<bool>(IsFinalRepresentationProperty); }
            set { SetValue(IsFinalRepresentationProperty, value); }
        }

        public static readonly PropertyData IsFinalRepresentationProperty = RegisterProperty("IsFinalRepresentation", typeof(bool), false);

        /// <summary>Signifies the Representation was used, as determined by the specific Representation type.</summary>
        public bool IsUsed
        {
            get { return GetValue<bool>(IsUsedProperty); }
            set { SetValue(IsUsedProperty, value); }
        }

        public static readonly PropertyData IsUsedProperty = RegisterProperty("IsUsed", typeof(bool), false);

        /// <summary>Signifies the Representation was interacted with, as determined by the specific Representation type.</summary>
        public bool IsInteractedWith
        {
            get { return GetValue<bool>(IsInteractedWithProperty); }
            set { SetValue(IsInteractedWithProperty, value); }
        }

        public static readonly PropertyData IsInteractedWithProperty = RegisterProperty("IsInteractedWith", typeof(bool), false);

        /// <summary>Any extra information relevant to the compiled Representation information.</summary>
        public List<string> AdditionalInformation
        {
            get { return GetValue<List<string>>(AdditionalInformationProperty); }
            set { SetValue(AdditionalInformationProperty, value); }
        }

        public static readonly PropertyData AdditionalInformationProperty = RegisterProperty("AdditionalInformation", typeof(List<string>), () => new List<string>());

        /// <summary>List of any Analysis Codes generated by the Representation.</summary>
        public List<string> AnalysisCodes
        {
            get { return GetValue<List<string>>(AnalysisCodesProperty); }
            set { SetValue(AnalysisCodesProperty, value); }
        }

        public static readonly PropertyData AnalysisCodesProperty = RegisterProperty("AnalysisCodes", typeof(List<string>), () => new List<string>());

        /// <summary>List of all the PageObject IDs used by this singular Representation construct.</summary>
        public List<string> PageObjectIDs
        {
            get { return GetValue<List<string>>(PageObjectIDsProperty); }
            set { SetValue(PageObjectIDsProperty, value); }
        }

        public static readonly PropertyData PageObjectIDsProperty = RegisterProperty("PageObjectIDs", typeof(List<string>), () => new List<string>());
        
        public string FormattedValue
        {
            get
            {
                // OJBJECT [ID] RepresentationInfo
                //      - Unused/No Interaction
                //      - Correct, LS
                //      - additional info
                //      - additional info
                //      - Codes:

                var header = $"{CodedObject} [{CodedID}] {RepresentationInformation}";
                var sections = new List<string>();

                var usage = IsUsed ? string.Empty : "Unused";
                if (string.IsNullOrWhiteSpace(usage))
                {
                    usage = IsInteractedWith ? string.Empty : "No Interaction";
                }
                if (!string.IsNullOrWhiteSpace(usage))
                {
                    sections.Add(usage);
                }

                if (Correctness != Correctness.Unknown)
                {
                    var correctnessSection = $"{Correctness}, {MatchedRelationSide}";
                    sections.Add(correctnessSection);
                }

                sections.AddRange(AdditionalInformation);

                var formattedAnalysisCodes = string.Join(", ", AnalysisCodes);
                var formattedAnalysisCodeSection = $"Codes: {formattedAnalysisCodes}";
                if (AnalysisCodes.Any())
                {
                    sections.Add(formattedAnalysisCodeSection);
                }

                var formattedSections = sections.Any() ? $"  - {string.Join("\n  - ", sections)}" : string.Empty;
                var formattedValue = $"{header}\n{formattedSections}";

                return formattedValue;
            }
        }

        #endregion // Properties
    }

    [Serializable]
    public class RepresentationsUsedTag : AAnalysisTagBase
    {
        #region Constructors

        public RepresentationsUsedTag() { }

        public RepresentationsUsedTag(CLPPage parentPage, Origin origin)
            : base(parentPage, origin) { }

        #endregion //Constructors

        #region Properties

        /// <summary>Identifies 3 possible usages scenarios: Ink Only, Blank Page, or Representations Used.</summary>
        public RepresentationsUsedTypes RepresentationsUsedType
        {
            get { return GetValue<RepresentationsUsedTypes>(RepresentationsUsedTypeProperty); }
            set { SetValue(RepresentationsUsedTypeProperty, value); }
        }

        public static readonly PropertyData RepresentationsUsedTypeProperty = RegisterProperty("RepresentationsUsedType", typeof(RepresentationsUsedTypes), RepresentationsUsedTypes.BlankPage);

        /// <summary>List of all Representations used on the page.</summary>
        /// <remarks>The IsUsed property can still be set to false, this is a list of all Representations added to the page, 
        /// the IsUsed property determines if the Representation was also used on the page in a significant fashion.</remarks>
        public List<UsedRepresentation> RepresentationsUsed
        {
            get { return GetValue<List<UsedRepresentation>>(RepresentationsUsedProperty); }
            set { SetValue(RepresentationsUsedProperty, value); }
        }

        public static readonly PropertyData RepresentationsUsedProperty = RegisterProperty("RepresentationsUsed", typeof(List<UsedRepresentation>), () => new List<UsedRepresentation>());
        
        #region ATagBase Overrides

        public override bool IsSingleValueTag => true;

        public override Category Category => Category.Representation;

        public override string FormattedName => "Representations Used";

        public override string FormattedValue
        {
            get
            {
                switch (RepresentationsUsedType)
                {
                    case RepresentationsUsedTypes.BlankPage:
                        return "Blank Page";
                    case RepresentationsUsedTypes.InkOnly:
                        return "Ink Only";
                }

                var deletedRepresentations = RepresentationsUsed.Where(r => !r.IsFinalRepresentation).ToList();
                var deletedSection = !deletedRepresentations.Any() ? string.Empty : $"Deleted Representation(s):\n{string.Join("\n", deletedRepresentations.Select(r => r.FormattedValue).ToList())}";

                var finalRepresentations = RepresentationsUsed.Where(r => r.IsFinalRepresentation).ToList();
                var finalSection = !finalRepresentations.Any() ? string.Empty : $"Final Representation(s):\n{string.Join("\n", finalRepresentations.Select(r => r.FormattedValue).ToList())}";

                var finalSectionDelimiter = deletedRepresentations.Any() && finalRepresentations.Any() ? "\n" : string.Empty;

                var codeSection = AnalysisCodes.Any() ? $"\n\nCodes: {string.Join(", ", AnalysisCodes)}" : string.Empty;
                return $"{deletedSection}{finalSectionDelimiter}{finalSection}{codeSection}";
            }
        }

        #endregion //ATagBase Overrides

        #endregion //Properties

        #region Static Methods

        public static RepresentationsUsedTag AttemptTagGeneration(CLPPage page, List<ISemanticEvent> semanticEvents)
        {
            var tag = new RepresentationsUsedTag(page, Origin.StudentPageGenerated);

            var leftRelation = RepresentationCorrectnessTag.GenerateLeftRelationFromPageAnswerDefinition(page);
            var rightRelation = RepresentationCorrectnessTag.GenerateRightRelationFromPageAnswerDefinition(page);
            var alternativeRelation = RepresentationCorrectnessTag.GenerateAlternativeRelationFromPageAnswerDefinition(page);

            GenerateArraysUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);
            GenerateNumberLinesUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);
            GenerateStampsUsedInformation(page, tag, semanticEvents, leftRelation, rightRelation, alternativeRelation);

            if (!tag.RepresentationsUsed.Any())
            {
                if (page.InkStrokes.All(s => s.GetStrokeOwnerID() == Person.AUTHOR_ID) &&
                    page.History.TrashedInkStrokes.All(s => s.GetStrokeOwnerID() == Person.AUTHOR_ID))
                {
                    tag.RepresentationsUsedType = RepresentationsUsedTypes.BlankPage;
                }
                else
                {
                    tag.RepresentationsUsedType = RepresentationsUsedTypes.InkOnly;
                }
            }
            else
            {
                tag.RepresentationsUsedType = RepresentationsUsedTypes.RepresentationsUsed;
            }

            var isMR2STEP = IsMR2STEP(tag);
            if (isMR2STEP)
            {
                tag.AnalysisCodes.Add(Codings.REPRESENTATIONS_MR2STEP);
            }

            page.AddTag(tag);
            return tag;
        }

        public static void GenerateArraysUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var patternPoints = new List<PatternPoint>();
            var completedPatternPoints = new List<PatternPoint>();
            var subArrayGroups = new Dictionary<string, List<string>>();

            #region Find Pattern Points

            foreach (var semanticEvent in semanticEvents.Where(e => e.CodedObject == Codings.OBJECT_ARRAY))
            {
                var arrayID = semanticEvent.ReferencePageObjectID;

                if (semanticEvent.EventType == Codings.EVENT_OBJECT_ADD)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = new PatternPoint
                                       {
                                           PageObjectID = arrayID,
                                           StartHistoryActionIndex = objectsChanged.HistoryActionIndex,
                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                           StartEventType = semanticEvent.EventType
                                       };
                    patternPoints.Add(patternPoint);
                }
                else if (semanticEvent.EventType == Codings.EVENT_CUT)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var pageObjectsCut = historyAction as PageObjectCutHistoryAction;
                    if (pageObjectsCut == null)
                    {
                        continue;
                    }

                    var patternPoint = patternPoints.FirstOrDefault(p => p.PageObjectID == arrayID);
                    if (patternPoint != null)
                    {
                        patternPoint.EndHistoryActionIndex = pageObjectsCut.HistoryActionIndex;
                        patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPoint.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPoint);
                        completedPatternPoints.Add(patternPoint);
                    }

                    foreach (var halvedArrayID in pageObjectsCut.HalvedPageObjectIDs)
                    {
                        var patternPointForArrayHalf = new PatternPoint
                                                       {
                                                           PageObjectID = halvedArrayID,
                                                           StartHistoryActionIndex = pageObjectsCut.HistoryActionIndex,
                                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                                           StartEventType = semanticEvent.EventType
                                                       };
                        patternPoints.Add(patternPointForArrayHalf);
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_SNAP)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var arraySnap = historyAction as CLPArraySnapHistoryAction;
                    if (arraySnap == null)
                    {
                        continue;
                    }

                    var persistingArrayID = arraySnap.PersistingArrayID;
                    var patternPointForPersistingArray = patternPoints.FirstOrDefault(p => p.PageObjectID == persistingArrayID);
                    if (patternPointForPersistingArray != null)
                    {
                        patternPointForPersistingArray.EndHistoryActionIndex = arraySnap.HistoryActionIndex;
                        patternPointForPersistingArray.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPointForPersistingArray.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPointForPersistingArray);
                        completedPatternPoints.Add(patternPointForPersistingArray);
                    }

                    var snappedArrayID = arraySnap.SnappedArrayID;
                    var patternPointForSnappedArray = patternPoints.FirstOrDefault(p => p.PageObjectID == snappedArrayID);
                    if (patternPointForSnappedArray != null)
                    {
                        patternPointForSnappedArray.EndHistoryActionIndex = arraySnap.HistoryActionIndex;
                        patternPointForSnappedArray.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                        patternPointForSnappedArray.EndEventType = semanticEvent.EventType;
                        patternPoints.Remove(patternPointForSnappedArray);
                        completedPatternPoints.Add(patternPointForSnappedArray);
                    }

                    var patternPointForNewArray = new PatternPoint
                                                  {
                                                      PageObjectID = persistingArrayID,
                                                      StartHistoryActionIndex = arraySnap.HistoryActionIndex,
                                                      StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                                      StartEventType = semanticEvent.EventType
                                                  };
                    patternPoints.Add(patternPointForNewArray);
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_DIVIDE_INK)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var eventInfo = semanticEvent.EventInformation;
                    var subArrays = eventInfo.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();
                    if (!subArrayGroups.ContainsKey(arrayID))
                    {
                        subArrayGroups.Add(arrayID, subArrays);
                    }
                    else
                    {
                        subArrayGroups[arrayID].AddRange(subArrays);
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_ARRAY_DIVIDE_INK_ERASE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var eventInfo = semanticEvent.EventInformation;
                    var subArrays = eventInfo.Split(", ", StringSplitOptions.RemoveEmptyEntries).ToList();
                    foreach (var subArray in subArrays)
                    {
                        if (!subArrayGroups.ContainsKey(arrayID))
                        {
                            continue;
                        }

                        if (!subArrayGroups[arrayID].Contains(subArray))
                        {
                            continue;
                        }

                        subArrayGroups[arrayID].Remove(subArray);
                        if (!subArrayGroups[arrayID].Any())
                        {
                            subArrayGroups.Remove(arrayID);
                        }
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_OBJECT_DELETE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = patternPoints.FirstOrDefault(p => p.PageObjectID == arrayID);
                    if (patternPoint == null)
                    {
                        continue;
                    }

                    patternPoint.EndHistoryActionIndex = objectsChanged.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                    patternPoint.EndEventType = semanticEvent.EventType;
                    patternPoints.Remove(patternPoint);
                    completedPatternPoints.Add(patternPoint);
                }
            }

            #endregion // Find Pattern Points

            foreach (var patternPoint in patternPoints)
            {
                patternPoint.EndHistoryActionIndex = semanticEvents.Last().LastHistoryAction.HistoryActionIndex;
                patternPoint.EndSemanticEventIndex = semanticEvents.Last().SemanticEventIndex;
                completedPatternPoints.Add(patternPoint);
            }

            foreach (var patternPoint in completedPatternPoints)
            {
                var arrayID = patternPoint.PageObjectID;
                var array = page.GetPageObjectByIDOnPageOrInHistory(arrayID) as CLPArray;
                if (array == null)
                {
                    continue;
                }

                var usedRepresentation = new UsedRepresentation();
                usedRepresentation.PageObjectIDs.Add(arrayID);

                #region Basic Representation Info

                if (string.IsNullOrWhiteSpace(patternPoint.EndEventType))
                {
                    usedRepresentation.IsFinalRepresentation = true;
                }

                usedRepresentation.CodedObject = Codings.OBJECT_ARRAY;
                usedRepresentation.CodedID = array.GetCodedIDAtHistoryIndex(patternPoint.EndHistoryActionIndex);
                usedRepresentation.IsInteractedWith =
                    semanticEvents.Where(e => e.ReferencePageObjectID == arrayID)
                                  .Any(
                                       e =>
                                           e.EventType == Codings.EVENT_ARRAY_SKIP || e.EventType == Codings.EVENT_ARRAY_DIVIDE_INK || e.EventType == Codings.EVENT_ARRAY_EQN ||
                                           (e.EventType == Codings.EVENT_INK_ADD && e.EventInformation.Contains(Codings.EVENT_INFO_INK_LOCATION_OVER)));
                usedRepresentation.IsUsed = true;

                if (subArrayGroups.ContainsKey(arrayID))
                {
                    // HACK - 2 existing strokes that create the same ink divide should combine. Ideally, this should be fixed in the DIVIDE INK event.
                    var subArrays = subArrayGroups[arrayID].ToList();
                    var subArraysToIgnore = new List<string>();

                    for (var i = 0; i < subArrays.Count - 1; i++)
                    {
                        var subArray = subArrays[i];
                        var trimmedSubArray = subArray.Replace('a', ' ').Replace('b', ' ').Replace('c', ' ').Replace('d', ' ').Replace('e', ' ').Replace('f', ' ').Replace('g', ' ').Replace('h', ' ').Trim();
                        for (var j = i + 1; j < subArrays.Count; j++)
                        {
                            var nextSubArray = subArrays[j];
                            var nextTrimmedSubArray = nextSubArray.Replace('a', ' ').Replace('b', ' ').Replace('c', ' ').Replace('d', ' ').Replace('e', ' ').Replace('f', ' ').Replace('g', ' ').Replace('h', ' ').Trim();

                            if (trimmedSubArray == nextTrimmedSubArray)
                            {
                                subArraysToIgnore.Add(trimmedSubArray);
                            }
                        }
                    }

                    subArraysToIgnore = subArraysToIgnore.Distinct().ToList();
                    foreach (var subArray in subArraysToIgnore)
                    {
                        subArrays.Remove(subArray);
                    }

                    usedRepresentation.RepresentationInformation = string.Join(", ", subArrays);
                }

                if (patternPoint.EndEventType == Codings.EVENT_CUT)
                {
                    usedRepresentation.AdditionalInformation.Add("Deleted by Cut");
                }

                if (patternPoint.EndEventType == Codings.EVENT_ARRAY_SNAP)
                {
                    usedRepresentation.AdditionalInformation.Add("Deleted by Snap");
                }

                if (patternPoint.StartEventType == Codings.EVENT_CUT)
                {
                    usedRepresentation.AdditionalInformation.Add("Created by Cut");
                }

                if (patternPoint.StartEventType == Codings.EVENT_ARRAY_SNAP)
                {
                    usedRepresentation.AdditionalInformation.Add("Created by Snap");
                }

                var mostRecentSkipEvent =
                    semanticEvents.LastOrDefault(
                                                 e =>
                                                     e.ReferencePageObjectID == arrayID && e.SemanticEventIndex <= patternPoint.EndSemanticEventIndex &&
                                                     (e.EventType == Codings.EVENT_ARRAY_SKIP || e.EventType == Codings.EVENT_ARRAY_SKIP_ERASE));

                if (mostRecentSkipEvent != null)
                {
                    var eventInfoParts = mostRecentSkipEvent.EventInformation.Split(", ");
                    if (eventInfoParts.Length == 2)
                    {
                        var formattedInterpretationParts = eventInfoParts[0].Split("; ");
                        if (formattedInterpretationParts.Length == 2)
                        {
                            var formattedSkips = formattedInterpretationParts[1];
                            if (!string.IsNullOrEmpty(formattedSkips))
                            {
                                // HACK: temporary print out of Wrong Dimension analysis
                                var skipStrings = formattedSkips.Split(' ').ToList().Select(s => s.Replace("\"", string.Empty)).ToList();
                                if (skipStrings.Count == 1 &&
                                    string.IsNullOrEmpty(skipStrings.First()))
                                {
                                    mostRecentSkipEvent =
                                        semanticEvents.LastOrDefault(
                                                                     e =>
                                                                         e.ReferencePageObjectID == arrayID && e.SemanticEventIndex <= patternPoint.EndSemanticEventIndex &&
                                                                         (e.EventType == Codings.EVENT_ARRAY_SKIP));

                                    if (mostRecentSkipEvent != null)
                                    {
                                        eventInfoParts = mostRecentSkipEvent.EventInformation.Split(", ");
                                        if (eventInfoParts.Length == 2)
                                        {
                                            formattedInterpretationParts = eventInfoParts[0].Split("; ");
                                            if (formattedInterpretationParts.Length == 2)
                                            {
                                                formattedSkips = formattedInterpretationParts[1];
                                                if (!string.IsNullOrEmpty(formattedSkips))
                                                {
                                                    skipStrings = formattedSkips.Split(' ').ToList().Select(s => s.Replace("\"", string.Empty)).ToList();
                                                }
                                            }
                                        }
                                    }
                                }

                                var skips = new List<int>();
                                foreach (var skip in skipStrings)
                                {
                                    if (string.IsNullOrEmpty(skip))
                                    {
                                        skips.Add(-1);
                                        continue;
                                    }

                                    int number;
                                    var isNumber = int.TryParse(skip, out number);
                                    if (isNumber)
                                    {
                                        skips.Add(number);
                                        continue;
                                    }

                                    skips.Add(-1);
                                }

                                var wrongDimensionMatches = 0;
                                for (int i = 0; i < skips.Count - 1; i++)
                                {
                                    var currentValue = skips[i];
                                    var nextValue = skips[i + 1];
                                    if (currentValue == -1 ||
                                        nextValue == -1)
                                    {
                                        continue;
                                    }
                                    var difference = nextValue - currentValue;
                                    if (difference == array.Rows &&
                                        array.Rows != array.Columns)
                                    {
                                        wrongDimensionMatches++;
                                    }
                                }

                                var wrongDimensionText = string.Empty;
                                if (skips.Count > 1)
                                {
                                    var percentMatchWrongDimensions = wrongDimensionMatches / ((skips.Count - 1) * 1.0);
                                    if (percentMatchWrongDimensions >= 0.80)
                                    {
                                        wrongDimensionText = ", wrong dimension";
                                    }
                                }
                                
                                var skipCodedValue = $"skip [{formattedSkips}]{wrongDimensionText}";
                                usedRepresentation.AdditionalInformation.Add(skipCodedValue);
                            }
                        }
                    }
                }

                #endregion // Basic Representation Info

                #region Representation Correctness

                // TODO: One-to-one comparison of each array at pattern points. Could take pattern point created by cut and consider those cut arrays as one?

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                var representationRelation = RepresentationCorrectnessTag.GenerateArrayRelation(array, patternPoint.EndHistoryActionIndex);

                var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                if (leftCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                    representationCorrectness = Correctness.Correct;
                }
                else if (rightCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                    representationCorrectness = Correctness.Correct;
                }
                else if (alternativeCorrectness == Correctness.Correct)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                    representationCorrectness = Correctness.Correct;
                }
                else if (leftCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (rightCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                {
                    matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                    representationCorrectness = Correctness.PartiallyCorrect;
                }
                else if (leftCorrectness == Correctness.Incorrect ||
                         rightCorrectness == Correctness.Incorrect ||
                         alternativeCorrectness == Correctness.Incorrect)
                {
                    representationCorrectness = Correctness.Incorrect;
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;
                if (representationRelation.IsSwapped)
                {
                    usedRepresentation.CorrectnessReason = Codings.PARTIAL_REASON_SWAPPED;
                }

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }
        }

        private class NumberLineJumpTotal
        {
            public NumberLineJumpTotal(string numberLineID, int startHistoryActionIndex)
            {
                NumberLineID = numberLineID;
                StartHistoryActionIndex = startHistoryActionIndex;
                IsPatternFinished = false;
                CurrentJumps = new List<NumberLineJumpSize>();
                TotalJumpsAfterLastJumpsAdded = new List<NumberLineJumpSize>();
                JumpEraseCount = 0;
                JumpEraseSinceLastAddCount = 0;
                LastJumpEraseHistoryActionIndex = -1;
                LastJumpEraseSemanticEventIndex = -1;
                IsUsingTotalJumpsAfterLastJumpsAdded = false;
            }

            public string NumberLineID { get; set; }
            public int StartHistoryActionIndex { get; set; }
            public int LastJumpEraseHistoryActionIndex { get; set; }
            public int LastJumpEraseSemanticEventIndex { get; set; }
            public bool IsUsingTotalJumpsAfterLastJumpsAdded { get; set; }
            public bool IsPatternFinished { get; set; }
            public List<NumberLineJumpSize> CurrentJumps { get; set; }
            public List<NumberLineJumpSize> TotalJumpsAfterLastJumpsAdded { get; set; }
            public int JumpEraseCount { get; set; }
            public int JumpEraseSinceLastAddCount { get; set; }
        }

        public static void GenerateNumberLinesUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var patternPoints = new List<PatternPoint>();
            var numberLineJumpTotals = new List<NumberLineJumpTotal>();

            #region Find Pattern Points

            foreach (var semanticEvent in semanticEvents.Where(e => e.CodedObject == Codings.OBJECT_NUMBER_LINE))
            {
                var numberLineID = semanticEvent.ReferencePageObjectID;

                if (semanticEvent.EventType == Codings.EVENT_OBJECT_ADD)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var patternPoint = new PatternPoint
                                       {
                                           PageObjectID = numberLineID,
                                           StartHistoryActionIndex = objectsChanged.HistoryActionIndex,
                                           StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                           StartEventType = semanticEvent.EventType
                                       };
                    patternPoints.Add(patternPoint);

                    var numberLineJumpTotal = new NumberLineJumpTotal(patternPoint.PageObjectID, patternPoint.StartHistoryActionIndex);
                    numberLineJumpTotals.Add(numberLineJumpTotal);
                }
                else if (semanticEvent.EventType == Codings.EVENT_NUMBER_LINE_JUMP)
                {
                    var jumpSizesChangedHistoryActions = semanticEvent.HistoryActions.OfType<NumberLineJumpSizesChangedHistoryAction>().ToList();
                    if (!jumpSizesChangedHistoryActions.Any())
                    {
                        continue;
                    }

                    var allJumps = new List<NumberLineJumpSize>();
                    foreach (var historyAction in jumpSizesChangedHistoryActions)
                    {
                        allJumps.AddRange(historyAction.JumpsAdded);
                    }

                    var numberLineJumpTotal = numberLineJumpTotals.First(jt => jt.NumberLineID == numberLineID && !jt.IsPatternFinished);

                    if (!numberLineJumpTotal.CurrentJumps.Any() &&
                        numberLineJumpTotal.JumpEraseSinceLastAddCount > 1)
                    {
                        var patternPoint = patternPoints.First(p => p.PageObjectID == numberLineID &&
                                                                    p.StartHistoryActionIndex == numberLineJumpTotal.StartHistoryActionIndex);
                        patternPoint.EndHistoryActionIndex = numberLineJumpTotal.LastJumpEraseHistoryActionIndex;
                        patternPoint.EndSemanticEventIndex = numberLineJumpTotal.LastJumpEraseSemanticEventIndex;
                        patternPoint.EndEventType = Codings.EVENT_NUMBER_LINE_JUMP_ERASE;

                        numberLineJumpTotal.IsPatternFinished = true;
                        
                        var newPatternPoint = new PatternPoint
                                              {
                                                  PageObjectID = numberLineID,
                                                  StartHistoryActionIndex = jumpSizesChangedHistoryActions.First().HistoryActionIndex,
                                                  StartSemanticEventIndex = semanticEvent.SemanticEventIndex,
                                                  StartEventType = semanticEvent.EventType
                                              };
                        patternPoints.Add(newPatternPoint);

                        numberLineJumpTotal = new NumberLineJumpTotal(newPatternPoint.PageObjectID, newPatternPoint.StartHistoryActionIndex);
                        numberLineJumpTotals.Add(numberLineJumpTotal);
                    }

                    numberLineJumpTotal.CurrentJumps.AddRange(allJumps);
                    numberLineJumpTotal.TotalJumpsAfterLastJumpsAdded = numberLineJumpTotal.CurrentJumps.ToList();
                    numberLineJumpTotal.JumpEraseSinceLastAddCount = 0;
                }
                else if (semanticEvent.EventType == Codings.EVENT_NUMBER_LINE_JUMP_ERASE)
                {
                    var jumpSizesChangedHistoryActions = semanticEvent.HistoryActions.OfType<NumberLineJumpSizesChangedHistoryAction>().ToList();
                    if (!jumpSizesChangedHistoryActions.Any())
                    {
                        continue;
                    }

                    var allJumps = new List<NumberLineJumpSize>();
                    foreach (var historyAction in jumpSizesChangedHistoryActions)
                    {
                        allJumps.AddRange(historyAction.JumpsRemoved);
                    }

                    var numberLineJumpTotal = numberLineJumpTotals.First(jt => jt.NumberLineID == numberLineID && !jt.IsPatternFinished);
                    var jumpsToRemove = (from jump in allJumps
                                         from currentJump in numberLineJumpTotal.CurrentJumps
                                           where jump.JumpSize == currentJump.JumpSize && jump.StartingTickIndex == currentJump.StartingTickIndex
                                         select currentJump).ToList();

                    numberLineJumpTotal.JumpEraseCount += jumpsToRemove.Count;
                    numberLineJumpTotal.JumpEraseSinceLastAddCount += jumpsToRemove.Count;
                    foreach (var jump in jumpsToRemove)
                    {
                        numberLineJumpTotal.CurrentJumps.Remove(jump);
                    }

                    if (!numberLineJumpTotal.CurrentJumps.Any() &&
                        numberLineJumpTotal.JumpEraseSinceLastAddCount > 1)
                    {
                        numberLineJumpTotal.IsUsingTotalJumpsAfterLastJumpsAdded = true;
                        numberLineJumpTotal.LastJumpEraseHistoryActionIndex = jumpSizesChangedHistoryActions.Last().HistoryActionIndex;
                        numberLineJumpTotal.LastJumpEraseSemanticEventIndex = semanticEvent.SemanticEventIndex;
                    }
                }
                else if (semanticEvent.EventType == Codings.EVENT_OBJECT_DELETE)
                {
                    var historyAction = semanticEvent.FirstHistoryAction;
                    var objectsChanged = historyAction as ObjectsOnPageChangedHistoryAction;
                    if (objectsChanged == null)
                    {
                        continue;
                    }

                    var numberLineJumpTotal = numberLineJumpTotals.First(jt => jt.NumberLineID == numberLineID && !jt.IsPatternFinished);
                    numberLineJumpTotal.IsPatternFinished = true;

                    var patternPoint = patternPoints.First(p => p.PageObjectID == numberLineID &&
                                                                p.StartHistoryActionIndex == numberLineJumpTotal.StartHistoryActionIndex);
                    patternPoint.EndHistoryActionIndex = objectsChanged.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvent.SemanticEventIndex;
                    patternPoint.EndEventType = semanticEvent.EventType;
                }
            }

            #endregion // Find Pattern Points

            foreach (var patternPoint in patternPoints)
            {
                var numberLineID = patternPoint.PageObjectID;
                var numberLine = page.GetPageObjectByIDOnPageOrInHistory(numberLineID) as NumberLine;
                if (numberLine == null)
                {
                    continue;
                }

                var numberLineJumpTotal = numberLineJumpTotals.First(jt => jt.NumberLineID == numberLineID && jt.StartHistoryActionIndex == patternPoint.StartHistoryActionIndex);
                var jumps = numberLineJumpTotal.IsUsingTotalJumpsAfterLastJumpsAdded ? numberLineJumpTotal.TotalJumpsAfterLastJumpsAdded : numberLineJumpTotal.CurrentJumps;

                var usedRepresentation = new UsedRepresentation();
                usedRepresentation.PageObjectIDs.Add(numberLineID);

                #region Basic Representation Info

                usedRepresentation.IsFinalRepresentation = false;
                if (patternPoint.EndHistoryActionIndex == -1)
                {
                    patternPoint.EndHistoryActionIndex = semanticEvents.Last().LastHistoryAction.HistoryActionIndex;
                    patternPoint.EndSemanticEventIndex = semanticEvents.Last().SemanticEventIndex;
                    usedRepresentation.IsFinalRepresentation = true;
                }

                usedRepresentation.CodedObject = Codings.OBJECT_NUMBER_LINE;
                usedRepresentation.CodedID = numberLine.GetCodedIDAtHistoryIndex(patternPoint.EndHistoryActionIndex);
                usedRepresentation.IsInteractedWith =
                    semanticEvents.Where(e => e.ReferencePageObjectID == numberLineID).Any(e => e.EventType == Codings.EVENT_NUMBER_LINE_JUMP || e.EventType == Codings.EVENT_NUMBER_LINE_CHANGE);
                usedRepresentation.IsUsed = numberLineJumpTotal.TotalJumpsAfterLastJumpsAdded.Any();
                if (usedRepresentation.IsUsed)
                {
                    usedRepresentation.RepresentationInformation = NumberLine.ConsolidateJumps(jumps.ToList());
                }

                if (!string.IsNullOrEmpty(usedRepresentation.RepresentationInformation))
                {
                    var jumpsInEnglish = new List<string>();
                    foreach (var codedJump in usedRepresentation.RepresentationInformation.Split("; ", StringSplitOptions.RemoveEmptyEntries))
                    {
                        try
                        {
                            var jumpSegments = codedJump.Split(", ", StringSplitOptions.RemoveEmptyEntries);
                            var jumpSize = int.Parse(jumpSegments[0]);
                            var jumpRange = jumpSegments[1].Split('-');
                            var start = int.Parse(jumpRange[0]);
                            var stop = int.Parse(jumpRange[1]);
                            var numberOfJumps = (stop - start) / jumpSize;
                            var jumpString = numberOfJumps == 1 ? "jump" : "jumps";
                            var jumpInEnglish = $"{numberOfJumps} {jumpString} of {jumpSize}";
                            jumpsInEnglish.Add(jumpInEnglish);
                        }
                        catch (Exception)
                        {
                            // ignored
                        }
                    }

                    usedRepresentation.AdditionalInformation.AddRange(jumpsInEnglish);
                }

                if (numberLineJumpTotal.JumpEraseCount > 1)
                {
                    usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_NLJE);
                }

                #endregion // Basic Representation Info

                #region Representation Correctness

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                var isSwapped = false;
                if (usedRepresentation.IsUsed)
                {
                    var jumpSizes = jumps;
                    var representationRelation = RepresentationCorrectnessTag.GenerateNumberLineRelation(jumpSizes);

                    var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                    var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                    var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                    if (leftCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (rightCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (alternativeCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (leftCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (rightCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (leftCorrectness == Correctness.Incorrect ||
                             rightCorrectness == Correctness.Incorrect ||
                             alternativeCorrectness == Correctness.Incorrect)
                    {
                        representationCorrectness = Correctness.Incorrect;
                    }

                    isSwapped = representationRelation.IsSwapped;
                }
                else
                {
                    var codedID = usedRepresentation.CodedID;

                    if (leftRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = leftRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }

                    if (rightRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = rightRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }

                    if (alternativeRelation?.PageDefinition is DivisionRelationDefinitionTag)
                    {
                        var product = alternativeRelation.Product;
                        double numberLineEndPoint;
                        if (double.TryParse(codedID, out numberLineEndPoint) &&
                            Math.Abs(product - numberLineEndPoint) < 0.0001)
                        {
                            usedRepresentation.AnalysisCodes.Add(Codings.NUMBER_LINE_BLANK_PARTIAL_MATCH);
                        }
                    }
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;
                if (isSwapped)
                {
                    usedRepresentation.CorrectnessReason = Codings.PARTIAL_REASON_SWAPPED;
                }

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }
        }

        public static void GenerateStampsUsedInformation(CLPPage page, RepresentationsUsedTag tag, List<ISemanticEvent> semanticEvents, SimplifiedRelation leftRelation, SimplifiedRelation rightRelation, SimplifiedRelation alternativeRelation)
        {
            var stampedObjectGroups = new Dictionary<int,int>();  // <Parts,Number of StampedObjects with Parts Value>
            var parentStampIDsOfParts = new Dictionary<int,List<string>>();
            foreach (var stampedObject in page.PageObjects.OfType<StampedObject>())
            {
                var parts = stampedObject.Parts;
                if (stampedObjectGroups.ContainsKey(parts))
                {
                    stampedObjectGroups[parts]++;
                }
                else
                {
                    stampedObjectGroups.Add(parts, 1);
                }

                if (parentStampIDsOfParts.ContainsKey(parts))
                {
                    parentStampIDsOfParts[parts].Add(stampedObject.ParentStampID);
                }
                else
                {
                    var parentStampIDs = new List<string>
                                         {
                                             stampedObject.ParentStampID
                                         };
                    parentStampIDsOfParts.Add(parts, parentStampIDs);
                }
            }

            foreach (var key in stampedObjectGroups.Keys)
            {
                var parts = key;
                var numberOfStampedObjects = stampedObjectGroups[key];

                var usedRepresentation = new UsedRepresentation();

                #region Basic Representation Info

                usedRepresentation.IsFinalRepresentation = true;

                usedRepresentation.CodedObject = Codings.OBJECT_STAMP;
                usedRepresentation.CodedID = parts.ToString();
                usedRepresentation.IsInteractedWith = true;
                usedRepresentation.IsUsed = true;
                usedRepresentation.RepresentationInformation = $"{numberOfStampedObjects} image(s)";

                var groupString = stampedObjectGroups[key] == 1 ? "group" : "groups";
                var englishValue = $"{stampedObjectGroups[key]} {groupString} of {parts}";
                usedRepresentation.AdditionalInformation.Add(englishValue);

                var parentStampsCount = parentStampIDsOfParts[key].Distinct().Count();
                var parentStampInfo = $"From {parentStampsCount} Stamps";
                usedRepresentation.AdditionalInformation.Add(parentStampInfo);

                #endregion // Basic Representation Info

                #region Representation Correctness

                var matchedRelationSide = Codings.MATCHED_RELATION_NONE;
                var representationCorrectness = Correctness.Unknown;
                if (usedRepresentation.IsUsed)
                {
                    var representationRelation = RepresentationCorrectnessTag.GenerateStampedObjectsRelation(parts, numberOfStampedObjects);

                    var leftCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, leftRelation);
                    var rightCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, rightRelation);
                    var alternativeCorrectness = RepresentationCorrectnessTag.CompareSimplifiedRelations(representationRelation, alternativeRelation);

                    if (leftCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (rightCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (alternativeCorrectness == Correctness.Correct)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.Correct;
                    }
                    else if (leftCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_LEFT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (rightCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_RIGHT;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (alternativeCorrectness == Correctness.PartiallyCorrect)
                    {
                        matchedRelationSide = Codings.MATCHED_RELATION_ALTERNATIVE;
                        representationCorrectness = Correctness.PartiallyCorrect;
                    }
                    else if (leftCorrectness == Correctness.Incorrect ||
                             rightCorrectness == Correctness.Incorrect ||
                             alternativeCorrectness == Correctness.Incorrect)
                    {
                        representationCorrectness = Correctness.Incorrect;
                    }

                    if (representationRelation.IsSwapped)
                    {
                        usedRepresentation.CorrectnessReason = Codings.PARTIAL_REASON_SWAPPED;
                    }
                }

                usedRepresentation.Correctness = representationCorrectness;
                usedRepresentation.MatchedRelationSide = matchedRelationSide;

                #endregion // Representation Correctness

                tag.RepresentationsUsed.Add(usedRepresentation);
            }
        }

        public static bool IsMR2STEP(RepresentationsUsedTag tag)
        {
            var leftSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_LEFT && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();
            var rightSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_RIGHT && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();
            var alternativeSideRepresentations = tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_ALTERNATIVE && r.Correctness == Correctness.Correct).Select(r => r.CodedObject).Distinct().ToList();

            var unmatchedRepresentations =
                tag.RepresentationsUsed.Where(r => r.MatchedRelationSide == Codings.MATCHED_RELATION_NONE && r.Correctness == Correctness.Incorrect).Select(r => r.CodedObject).Distinct().ToList();

            // TODO: Doesn't handle altReps

            if (!leftSideRepresentations.Any() ||
                !rightSideRepresentations.Any())
            {
                return false;
            }

            foreach (var leftSideRepresentation in leftSideRepresentations)
            {
                if (!rightSideRepresentations.Contains(leftSideRepresentation))
                {
                    return true;
                }

                if (unmatchedRepresentations.Any() &&
                    !unmatchedRepresentations.Contains(leftSideRepresentation))
                {
                    return true;
                }
            }

            return false;
        }

        #endregion // Static Methods
    }
}